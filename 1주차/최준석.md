### 발단

- Duck Class를 상속받아 MallardDuck, RedheadDuck 등을 구현해 사용중에 fly라는 신 기능을 구현해야 할 일이 생김
- 개발자는 부모 Class인 Duck에 fly메소드를 만들어 이걸 상속받는 Class에서 해당 메소드를 사용할 수 있게 만듬

### 문제 발생

- fly라는 메소드를 사용할 수 있어야 하는 Duck Class의 자식 Class들도 있지만 아닌 Class들도 있음. 그러나 모든 자식 Class에 해당 메소드가 구현되게 됨

### 해결책 1

- fly기능이 없어야 하는 Class에는 해당 메소드를 실행해도 문제가 없게 override

### 이슈

- Duck Class의 모든 자식 Class에 해당 기능이 구현되어 있으므로, 해당 기능이 필요없는 경우 일일이 찾아서 override 해줘야 하고. 해당 기능 관련 변경사항이 발생할 때마다 모든 Case를 찾아서 수정해줘야 함
  -> 단순 상속은 해결책이 아님

<디자인 원칙> : 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
<디자인 원칙> : 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.

### 해결책 2

- 기능에 대한 인터페이스를 만들고 해당 인터페이스를 구현한 Class에 메소드를 구현한다. 그리고 해당 인터페이스 타입을 가지는 참조변수를 선언한 후, 자식 Class에서 맞는 인스턴스를 해당 참조변수에 할당한 후 메소드를 사용한다.

### 이슈

- Duck Class의 자식 Class 내부에서 기능에 대한 인스턴스 할당이 이루어지고 있어서, 상황에 따라 해당 Class의 기능을 동적으로 변경하기가 어려움

### 해결책 3

- 해당 기능 참조변수에 인스턴스를 재 할당하는 set메소드를 구현해 외부에서 자식 Class의 기능을 상황에 따라 변경할 수 있도록 함

<디자인 원칙> : 상속보다는 구성을 활용한다.

### 전략패턴 : 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해줌. 전략 패턴을 사용하면 크르라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음.
