<1Chapter - 디자인 패턴의 세계로 떠나기>

상속의 단점
- 서브클래스 코드 중복
- 실행 시에 특징 변경 어려움
- 모든 오리의 행동 알기 어려움
- 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있음

Duck model = new ModelDuck();
model.performFly(); => 출력: '저는 못 날아요'
model.setFlyBehavior(new FlyRoketPowered); => 상속받은 행동 세터 메서드가 호출되어 날 수 있게 됨
model.performFly(); => 출력: '로켓 추진으로 날아갑니다!'
==> 실행 중에 오리의 행동을 바꾸고 싶으면 원하는 행동에 해당하는 Duck의 세터 메서드를 호출하면 됨!

오리들은 모두 Duck 클래스를 확장해서 만듦
나는 행동과 꽥꽥거리는 행동은 어떤 오리냐에 따라 달라질 수 있기 때문에
  - 나는 행동은 FlyBehavior 인터페이스로 캡슐화
    - FlyWithWings, FlyNoWay 클래스로 구현, 이를 '알고리즘군'이라고 함
  - 꽥꽥거리는 행동은 QuackBehavior 인터페이스로 캡슐화
    - Quack, Squeak, MuteQuack 클래스로 구현, 이를 '알고리즘군'이라고 함
오리는 나는 행동과 꽥꽥거리는 행동 2가지를 모두 사용할 수 있음 (알고리즘군을 Duck 클래스에서 사용)
  - 이렇게 두 클래스를 합치는 것을 '구성'을 이용한다고 부름
  - 오리 클래스는 행동을 '상속'받는 대신 올바른 행동 객체로 '구성'되어 행동을 부여받는다

디자인 원칙: 상속보다는 구성을 활용한다

구성을 활용하면 좋은 점
1. 시스템 유연성 향상
2. 알고리즘군을 별도의 클래스 집합으로 캡슐화 가능하며 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행 시에 행동 변경 가능

Q. 뇌 단련.... Duck 클래스 없이 오리 소리(꽥꽥 소리)를 내는 오리 호출기 구현하는 방법은?
A. 소리만 낼거면 Duck 클래스 필요없이 Quack 클래스를 만들어서 사용하면 된다


===> 이것이 바로 '전략 패턴'이다!
전략 패턴은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다.
전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.

객체지향 기초
1. 추상화
2. 캡슐화
3. 다형성
4. 상속

객체지향 원칙
1. 바뀌는 부분을 캡슐화한다
2. 상속보다는 구성을 활용한다
3. 구현보다는 인터페이스에 맞춰서 프로그래밍한다


-- 기억에 남는 부분 --
a = getAnimal();
a.makeSound();
=> Animal의 하위 형식 가운데 어떤 형식인지는 모릅니다. 단지 makeSound()에 올바른 반응만 할 수 있으면 됩니다.
사실 코드가 방대해질수록 모든 부분을 파헤치기 어려운데, 그 부분을 간파한 느낌이라서 인상깊었다.
---------------------
인터페이스를 잘 몰랐는데 이번 기회에 추가적으로 찾아보면서 공부할 수 있어 좋았음
항상 헷갈리는 추상 클래스와 인터페이스의 차이..
---------------------
인터페이스끼리는 다중 상속이 가능하기 때문에 JAVA 클래스에서 할 수 없는 다중 상속 기능을 어느정도 대체할 수 있다.
클래스에서 다중 상속을 하면 어떤 메서드를 따라야할지 모호하기 때문에 JAVA에서는 클래스 다중 상속을 지원하지 않는다.
