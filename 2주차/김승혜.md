<2Chapter - 객체들에게 연락 돌리기, 옵저버 패턴>
기상 모니터링 어플리케이션
1. 현재 조건
2. 기상 통계
3. 기상 예보
갱신된 값을 가져올 때마다 measurementsChanged() 메서드 실행됨 (디스플레이 업데이트)
디스플레이가 나중에 늘어날 수 있음. 마켓플레이스로 사용자가 마음대로 디스플레이 요소를 더하거나 뺄 수 있게 해 주는 확장성 생각. 

옵저버 패턴 - 12장에서 더 배움!
- 주제, 옵저버
- 주제 데이터가 바뀌면 옵저버에게 소식 전달됨
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의
- 주제가 옵저버에게 데이터를 보내는 푸시.
- 주제가 게터메서드를 가지고 옵저버가 주제로부터 데이터를 당겨오는 풀.
(1) 인터페이스 Subject(주제): 옵저버 등록 메서드, 옵저버 제거 메서드, 옵저버 공지 메서드....
(2) 인터페이스 Observer(옵저버): update() <- 무조건 주제의 상태가 바뀌었을 때 호출되는 update() 메서드만 존재
(2-2)클래스 ConcreteObserver: update() <- Observer 인터페이스 구현
(1-2)클래스 ConcreteSubject: 옵저버 등록 메서드, 옵저버 제거 메서드, 옵저버 공지 메서드 <- Subject 인터페이스 구현

느슨한 결합
- 객체들이 상호작용할 수는 있지만 서로를 잘 모르는 관계를 의미
- 느슨한 결합을 활용하면 유연성이 아주 좋다
=> 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다
- 옵저버 패턴은 느슨한 결합을 보여주는 훌륭한 예시
  1. 옵저버의 구상 클래스가 무엇인지, 무엇을 하는지 알 필요 없다
  2. 옵저버는 언제든지 추가/제거 가능
  3. 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요 없다
	  - 새로운 클래스에서 Observer 인터페이스 구현하고 옵저버 등록하기만 하면 어떤 객체에도 연락 가능
  4. 주제와 옵저버는 서로 독립적으로 재사용 가능
  5. 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않음

<3Chapter - 객체 꾸미기, 데코레이터 패턴>
디자인 원칙 OCP
- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다
- 무조건 OCP를 적용하면 시간 낭비나 필요 이상으로 복잡한 코드를 만들게 되는 부작용 발생
=> 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP 적용

데코레이터 패턴
- 데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
- 커피 ex) Whip > Mocha > DarkRoast (셋 다 cost()  메서드 가지고 있음)
1. 우선 가장 바깥쪽에 있는 데코레이터인 whip의 cost() 메서드 호출
2. Whip은 Mocha의 cost() 메서드 호출
3. Mocha는 다시 DarkRoast의 cost() 메서드 호출
4. DarkRoast는 99센트 리턴
5. Mocha는 DarkRoast로부터 리턴받은 가격에 모카 값 20센트를 더해서 총 1.19달러를 리턴
6. Whip은 Mocha로부터 받은 가격에 10센트를 다시 추가해서 최종 결과인 1.29달러를 리턴
- 특징
  - 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다
  - 한 객체를 여러 개의 데코레이터로 감쌀 수 있다
  - 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 겍체(싸여 있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다
  - 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위힘하는 일 말고도 추가 작업을 수행할 수 있다
  - 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다
